进程是资源的集合，线程是CPU上的执行单元；

并行和并发的概念

多道技术

进程并发的实现：通过硬件中断运行中的进程，并保护现场（PCB）

threading:
由于GIL的存在，同一时刻同一进程中只有一个线程运行的一个CPU上。即无法实现真正意义上的多线程的并行；
join()  阻塞父线程
setDaemon() 声明为守护线程   当声明子线程为守护线程时，主线程结束后，子线程也立即结束；
同步锁Lock(): 对共享资源的访问实现互斥；有死锁的风险，引入Rlock（）
同步条件 Event对象：线程间同步的方式，通过设置标志位来控制依赖此标志位的线程的执行流程；
Semaphore（信号量）：控制同一时间可以同时获得信号量的线程的个数。每当调用acquire()时内置计数器-1/调用release() 时内置计数器+1
由于GIL的存在,使用python中的多线程时：
IO密集型：python多线程可以节省时间；
计算密集型：python多线程不会节省时间；

解决由于GIL导致python的多线程效果不好的问题：
1.python使用多核，即开多个进程。
方法一：多进程。使用方法简单，效率还可以，一般使用该方法。
方法二：协程yield是你自己写的，是自己定义什么时候切换进程。　　
方法三：IO多路复用。使用复杂，但效率很高。不常用。
2.终极思路：换C模块实现多线程，即换一个python解释器，或者换门编程语言避免GIL锁。


多进程：
multiprocessing/Process
每个进程有独立的GIL，解决多线程GIL的限制的问题。
但带来的问题：进程间数据通信和同步的问题
进程间通信：
Queue/Pipe/Manager/Pool

协程：
yield和协程 
1.由于是单线程，不能再切换
2.不再有任何锁的概念

yield实现的生成器(协程的初始)
1.yield 关键字必须要定义在一个函数中，否则会报错；2.一个函数中如果有yield，那这个函数就是一个生成器；

greenlet（手动切换）
greenlet机制的主要思想是：生成器函数或者协程函数中的yield语句挂起函数的执行，直到稍后使用next()或send()操作进行恢复为止。可以使用一个调度器循环在一组生成器函数之间协作多个任务。greenlet是python中实现我们所谓的"Coroutine(协程)"的一个基础库.

gevent
自动切换
gevent是第三方库，通过greenlet实现协程
当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。


IO多路复用：
IO模型：
常用模型分为4种：
1.阻塞IO
2.非阻塞IO
3.IO多路复用
4.异步IO

阻塞IO和非阻塞IO：
阻塞IO：进程不能做其他的事情
非阻塞IO：等待数据无阻塞


阻塞IO
全程阻塞，不管是等待数据或者是从内核态拷贝数据到用户态
系统调用两个阶段：
wait for data 阻塞
copy data 阻塞

非阻塞IO
setblocking(False) 设置阻塞状态为非阻塞
固定时间循环发起系统调用，请求不到做自己的事情，等待下次请求，内核态拷贝数据到用户态需要等待
系统调用两个阶段：
wait for data 非阻塞
copy data 阻塞
优点：等待数据无阻塞
缺点：系统调用发送太多；数据不是即时接收的


同步IO和异步IO：
有阻塞就是同步IO，所以，
阻塞IO、非阻塞IO、IO多路复用是同步IO
异步IO是异步IO


异步IO
全程无阻塞，实现复杂


IO多路复用
全程阻塞，监听多个链接
系统调用select完成wait for data工作
系统调用两个阶段：
wait for data 阻塞
copy data 阻塞
特点：监听多个文件描述符，实现并发

r,w,e = select.select([sock,],[],[]) #等待链接
for obj in r:
    conn,addr = obj.accept()


	
inputs = [sock,]
r,w,e = select.select(inputs,[],[]) #inputs监听有变化的套接字 inputs=[sock,conn1,conn2,...]
for obj in r: #第一次[cock,] 第二次[conn1,]
    if obj == sock
        conn,addr = obj.accept()
        inputs.append(conn) #inputs=[sock,conn1,conn2]
    else:
        data = obj.recv(1024)


对于文件描述符（socket套接字）：
1.每一个套接字对象的本质就是一个非零整数，不会变（fb=4）
2.收发数据的时候，对于接收端而言，数据先到内核空间，然后copy到用户空间，同时内核空间的数据被清空
3.根据TCP协议，当发送端接收到接收端的确认信息后，清空内核空间的数据，否则不清空



IO模型 - IO多路复用实现机制
IO模型 - selectors模块
IO多路复用实现机制
IO多路复用机制：就是单个process可以同时处理多个网络连接的IO，基本原理就是通过select／epoll函数不断轮询所负责的所有socket，当某个socket有数据到达，就通知用户进程。
不同的操作系统提供的函数不同：
    windows系统： select
    linux系统： select、poll、epoll

简单介绍select、poll、epoll三者的特点：

select的缺点有以下三点，会导致效率下降：
    1.每次调用select都要将所有的fd（文件描述符），copy到你的内核空间
    2.遍历所有的fd，是否有数据访问
    3.最大连接数（1024），超出链接不再监听
     
poll：
    与select一样，只是最大连接数没有限制
 
epoll不同于select和poll只有一个函数，epoll通过三个函数实现实现轮询socket：
    1.第一个函数：创建epoll句柄：将所有的fd（文件描述符），copy到你的内核空间，只copy一次
    2.回调函数：为所有fd绑定一个回调函数，一旦有数据访问，触发回调函数，回调函数将fd放入一个链表中（回调函数：某一个函数或者某一个动作，成功完成之后，会触发的函数）
    3.第三个函数：判断链表是否为空
epoll最大连接数没有上线


队列queue
队列与线程（和进程）有关，保证多线程信息交换的安全。
队列是一种数据类型（数据结构），可用于存放数据  创建队列语法queue.Queue()，默认是先进先出（FIFO）。
队列的优点：保证线程安全
get与put方法

应用范例：
生产者消费者模型
在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。
生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。
这就像，在餐厅，厨师做好菜，不需要直接和客户交流，而是交给前台，而客户去饭菜也不需要不找厨师，直接去前台领取即可，这也是一个解耦的过程。

	
总结：

进程：最小的资源管理单位（盛放线程的容器）

线程：最小的执行单位

串行、并行、并发

cpython因为存在GIL导致，同一时刻，同一进程只能有一个线程执行

关于daemon：程序直到不存在非守护线程时退出

同步锁：由于多线程处理公共数据

递归锁

event：一个对象，让多个进程间通信		



应用总结：
1.IO模型中， 主要应用的是IO多路复用 模型，实现的python模块包括： select, poll, epoll,selectors
2.threading中关注 queue模块的应用和 应用实例（生产者和消费者模型）
3.yield和协程
1）单线程模式下，使用yield实现类似“多协程”的工作模型；
2）greenlet是python中实现我们所谓的"Coroutine(协程)"的一个基础库，可以使用一个调度器循环在一组生成器函数之间协作多个任务，为手动切换；
3）gevent为自动切换，是第三方库，通过greenlet实现协程，当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行
4. multiprocessing模块：进程间通讯 （进程队列Queue、管道(pipe)、manager、进程池）
5.多线程，数据同步相关：
同步锁 (Lock)、死锁与递归锁、同步条件 Event对象、Semaphore（信号量）
6.threading模块：
线程对象的创建，join()方法，setDaemon()方法，GIL(全局解释器锁)
7.因为GIL的存在，python中在使用cpython时无法实现真正的多线程解决方案如下：
python使用多核，即开多个进程。
方法一：协程+多进程。使用方法简单，效率还可以，一般使用该方法。 （multiprocssing ,yield）
　　　　协程yield是你自己写的，是自己定义什么时候切换进程。　　
方法二：IO多路复用。使用复杂，但效率很高。不常用。 (select,poll,epoll,selectors)

